# 実装履歴

- 初回生成: frontend(Svelte+Vite) と backend(PHP MVC) を作成。
- WebCodecsパイプライン: `demuxer.js` で mp4box を用いた逐次デマックス、`encoder.js` で Video/Audio 並列エンコードと mp4-muxer へのストリーム書き込みを実装。
- APIクライアント: `src/lib/api/client.js` にプリセット取得/投稿APIを実装。
- UI: `App.svelte` にドロップゾーン、プリセット選択、進捗/FPS表示、共有送信を実装。
- Backend: `public/api/index.php` エントリ、`PresetController`/`PostController`、`Database`/`ApiController` を実装。`database.sql` にDDL/DML投入。

## 2025-12-23 修正
- frontend/lib/encoder.js: mp4-muxer 初期化時に `firstTimestampBehavior: 'offset'` を設定し、入力トラックの先頭タイムスタンプが0でない場合でも自動的にゼロ起点へオフセットするよう対応。これにより "The first chunk for your media track must have a timestamp of 0" エラーを解消。
- frontend/index.html: 進捗表示のFPS/経過時間のフォーマットを安全化。`stats.fps`/`stats.elapsedMs` が未定義や非有限値の場合に `toFixed` を呼ばないようガードし、`-` を表示するように変更。これにより `Cannot read properties of undefined (reading 'toFixed')` を解消。
 - frontend/lib/demuxer.js: デマックス時に動画サンプルから総デュレーション（microseconds）を算出し、`durationUs` として返却。
 - frontend/lib/encoder.js: エンコードの出力メタデータ（timestamp/duration）から処理済みデュレーションを推定し、進捗を 80→90% の間で連続更新。Flush/Finalize の進捗は 90→98→100% に調整し、80%固定に見えないよう改善。
 - frontend/lib/encoder.js: mp4-muxer へ渡す `meta.timestamp` を最初の出力タイムスタンプ基準で正規化（先頭を0起点に調整）。`firstTimestampBehavior` が効かないケースでも、強制的にゼロ起点になるよう安全策を追加。
+ - frontend/index.html, frontend/lib/encoder.js: 単一プログレスバーから**4つのステージ別プログレスバー**（ファイル読み込み、エンコード、フラッシング、ファイナライズ）へ UI を改善。onProgress の呼び出し形式を `{ stage, percent, fps, elapsedMs }` オブジェクト形式に統一し、各段階の進捗を個別に表示できるよう対応。

## 2026-01-13 出力ファイル空ファイル問題の根本原因調査

### 問題症状
- エンコーディング処理は完了：`Total video chunks: 1134`、Duration 正しく計算（38433300 μs）
- しかし出力 MP4 ファイルが **1021 バイト**（ヘッダのみ）でビデオフレームデータなし
- mediainfo 確認結果：FrameCount: 0、Duration: 0.000s
- **全てのビデオ/オーディオチャンクが muxer に追加されていない**

### 根本原因
```
Error: The first chunk for your media track must have a timestamp of 0
```
→ VideoEncoder 出力の EncodedVideoChunk.timestamp が 37.8 秒（37800000 μs）から開始
→ mp4-muxer の `firstTimestampBehavior: 'offset'/'remove'` オプションが**バリデーション前に処理されていない**
→ ライブラリが最初に timestamp をチェック → エラー投げ → オプション処理に到達せず
→ try-catch でエラー無視 → **chunk 追加に失敗したまま**

### 実装修正内容
**encoder.js に詳細ログ追加：**
1. `videoChunkAddedCount`、`audioChunkAddedCount` 変数追加
2. VideoEncoder/AudioEncoder の output callback に try-catch 追加
3. エラー時は詳細情報をログ出力（timestamp、duration、エラー完全メッセージ）
4. 最終ログに「追加成功数 / 総エンコード数」を表示

**ログ出力例：**
```
✓ Video chunks added: 100/1134
✗ Failed to add chunk #101: { message: "...", timestamp: ..., normalizedTs: ..., ... }
Total video chunks added to muxer: X / 1134
Total audio chunks added to muxer: Y / audioChunkCount
```

### 次ステップ
1. **ブラウザ再読み込み**（キャッシュクリア推奨）

---

## 2026-01-13 mp4-muxer初期化タイミング問題修正 + 2パスエンコーディング実装

### 問題症状（第2フェーズ）
- ログに「✅ Counters reset for second encoding pass」は表示される
- しかし最初のチャンクが `type: 'delta'`（キーフレームでない）になる
- mp4-muxer エラー: **"The first chunk must have a type of 'key'"**
- **結果**: 全チャンク追加失敗（18チャンクのみ追加、1135チャンク失敗）

### 根本原因
1. **VideoEncoderが最初のフレームをdeltaフレームとしてエンコード**している
2. mp4-muxerは**最初のチャンクが必ずキーフレーム（type: 'key'）でなければならない**という要件がある
3. VideoEncoderに明示的に「最初のフレームをキーフレームにする」指定がなかった

### 実装修正内容

**1. VideoEncoder設定に AVC形式指定追加（encoder.js）：**
```javascript
videoEncoder.configure({
    codec: config.video.codec ?? 'avc1.640028',
    width: actualWidth,
    height: actualHeight,
    bitrate: config.video.bitrate,
    framerate: config.video.framerate,
    latencyMode: 'quality',
    avc: { format: 'avc' }  // ← 追加
});
```

**2. 最初のフレームを強制的にキーフレーム化（encoder.js）：**
```javascript
// VideoDecoder の output callback 内
try {
    // 最初のフレームは強制的にキーフレームにする
    const encodeOptions = (frameCount === 1) ? { keyFrame: true } : undefined;
    videoEncoder.encode(frame, encodeOptions);
} catch (encErr) {
    // ...
}
```

### 期待される動作
1. 2回目のdemuxAndDecode()開始時に`frameCount = 0`にリセット
2. 最初のフレーム（frameCount = 1）が`videoEncoder.encode(frame, { keyFrame: true })`で処理される
3. VideoEncoderが**必ずキーフレーム（type: 'key'）として出力**
4. mp4-muxerが正常に最初のチャンクを受け入れる
5. STTSテーブルが正しく構築され、VLCで再生可能

### 次ステップ
1. **ブラウザ完全再読み込み**（Ctrl+Shift+R）
2. 同じ動画ファイルでエンコード実行
3. コンソールログで確認:
   - `🎬 FIRST VIDEO CHUNK: {type: 'key', ...}` ← **'key'になっているか確認**
   - `[CHUNK 1] ts: 0, dur: 33333, type: key` ← **'key'になっているか確認**
   - エラーなく1135チャンク全て追加成功するか確認
4. VLCで出力ファイル再生して黒画面でないか確認

---

## 2026-01-13 VideoEncoderキュークリア追加

### 問題症状（第3フェーズ）
- 修正後も最初のチャンクが`type: 'delta'`のまま
- タイムスタンプが37800000μs（約37.8秒）から開始
- これは**1回目のエンコード（フォーマット検出パス）の残りチャンク**

### 根本原因
VideoEncoderは同じインスタンスを1回目・2回目で共有している。
1回目のdemuxAndDecode()でエンコードしたチャンクが**VideoEncoderの内部キューに残留**。
2回目のdemuxAndDecode()開始時、1回目の残りチャンクが先に出力される。
→ カウンターは`frameCount=1`だが、実際に出力されるのは1回目の途中チャンク（deltaフレーム）

### 実装修正内容

**STEP 2（VideoEncoder再設定）に flush() 追加：**
```javascript
// 1回目のエンコードキューをクリア
await videoEncoder.flush();
console.log('✅ VideoEncoder flushed (1st pass queue cleared)');

videoEncoder.configure({
    codec: config.video.codec ?? 'avc1.640028',
    width: actualWidth,
    height: actualHeight,
    bitrate: config.video.bitrate,
    framerate: config.video.framerate,
    latencyMode: 'quality',
    avc: { format: 'avc' }
});
```

### 期待される動作
1. STEP 1: 1回目のdemuxAndDecode()でフォーマット検出（チャンク出力あり）
2. STEP 2: **videoEncoder.flush()**で1回目のキューを完全クリア
3. STEP 2: videoEncoder.configure()で新しい設定適用（1920x1080）
4. STEP 5: 2回目のdemuxAndDecode()開始、**最初のフレームが{ keyFrame: true }で強制キーフレーム化**
5. 最初の出力チャンクが`type: 'key'`, `timestamp: 0`で出力
6. mp4-muxerが正常受理、全1153フレームエンコード成功

### 次ステップ
1. **Ctrl+Shift+R で完全リロード**
2. エンコード実行
3. コンソール確認:
   ```
   ✅ VideoEncoder flushed (1st pass queue cleared)
   🎬 FIRST VIDEO CHUNK: {timestamp: 0, type: 'key', ...}  ← keyであること
   [CHUNK 1] ts: 0.00ms, dur: 33.33ms, type: key          ← ミリ秒単位
   [CHUNK 2] ts: 33.33ms, dur: 33.33ms, type: delta       ← 正しい増加
   Video chunks ADDED to muxer: 1153/1153                  ← 全て成功
   ```
4. VLC再生: 映像が正常表示されるか確認

---

## 2026-01-13 **重大発見**: タイムスタンプ単位不一致問題修正

### 問題症状（第4フェーズ）
- エンコード成功、全1135チャンク追加成功
- しかし**VLCでSTTS table of 1 entries**のまま（1153サンプルあるのに）
- 映像が再生されない（黒画面・デッドロック）

### 根本原因（ドキュメント調査で判明）
**mp4-muxerのGLOBAL_TIMESCALE = 1000（ミリ秒基準）**

ソースコード（src/muxer.ts）:
```typescript
export const GLOBAL_TIMESCALE = 1000;  // ← ミリ秒単位！
```

現在のコードは**マイクロ秒（μs）**でタイムスタンプを渡している：
```javascript
// 間違い：
muxer.addVideoChunk(chunk, { timestamp: 0, duration: 33333 });  // 33333μs = 33.333ms
// mp4-muxerはこれを「33333ミリ秒 = 33.333秒」として解釈！
```

結果：
- 30FPSの動画が**1FPS相当**のタイムスタンプになる
- MP4のSTTSテーブルが正しく構築されない
- VLCがタイムスタンプを正しく解釈できない

### 実装修正内容

**encoder.js VideoEncoder output callback修正：**
```javascript
// ⚠️ mp4-muxerは「ミリ秒」単位のタイムスタンプを期待
const tsUs = Number(chunk.timestamp) || 0;
const durUs = Number(chunk.duration) || 0;

if (videoBaseTsUs === null) {
    videoBaseTsUs = tsUs;
}
const normalizedTsUs = Math.max(0, tsUs - videoBaseTsUs);

// マイクロ秒 → ミリ秒に変換（mp4-muxer要件）
const finalTsMs = (videoChunkCount === 1 ? 0 : normalizedTsUs) / 1000;
const durationMs = durUs / 1000;

muxer.addVideoChunk(chunk, { timestamp: finalTsMs, duration: durationMs });
```

### 期待される動作
1. VideoEncoderは従来通りマイクロ秒単位で出力（33333μs, 66667μs, ...）
2. 内部計算（videoBaseTsUs、normalizedTsUs）はマイクロ秒のまま
3. **mp4-muxerに渡す直前に÷1000でミリ秒変換**
4. mp4-muxerが正しいタイムスタンプでMP4構築:
   - Chunk 1: 0ms
   - Chunk 2: 33.333ms
   - Chunk 3: 66.667ms
   - ...
5. STTSテーブルが正常に構築される（1153エントリー）
6. VLCが正常再生

### 次ステップ
1. **Ctrl+Shift+R で完全リロード**
2. エンコード実行
3. **コンソールログ確認**（ミリ秒表示に変更されている）:
   ```
   [CHUNK 1] ts: 0.00ms, dur: 33.33ms, type: key
   [CHUNK 2] ts: 33.33ms, dur: 33.33ms, type: delta
   [CHUNK 3] ts: 66.67ms, dur: 33.33ms, type: delta
   ```
4. **VLCで再生テスト**: 映像が正常表示され、STTS table of 1153 entries

---

## 2026-01-13 **追加修正**: addVideoChunkRaw()使用でduration単位問題解決

### 問題症状（第5フェーズ）
- タイムスタンプは正しくミリ秒変換済み（ログ確認: `ts: 0.00ms, ts: 33.33ms, ...`）
- しかし**VLCでSTTS table of 1 entries**のまま
- 映像再生不可（黒画面・デッドロック）

### 根本原因（第2段階）
`addVideoChunk(chunk, meta, timestamp)`のAPI仕様:
- 第3引数`timestamp`は上書き可能 → ✅ ミリ秒変換済み
- しかし`chunk.duration`は**上書き不可能** → ❌ マイクロ秒のまま使用される

結果：
```javascript
muxer.addVideoChunk(chunk, metaAdj);  // ❌ 内部でchunk.duration（33333μs）をそのまま使用
// mp4-muxerは33333msとして解釈 → 33.333秒のduration！
```

実際のファイル:
- 1135チャンク × 33秒 = **37755秒 = 10.5時間のduration**
- STTSテーブルが異常値で1エントリーに収束

### 実装修正内容

**addVideoChunk() → addVideoChunkRaw()に変更:**
```javascript
// ❌ 旧コード（durationがマイクロ秒のまま）:
muxer.addVideoChunk(chunk, { timestamp: finalTsMs, duration: durationMs });

// ✅ 新コード（timestamp/duration両方をミリ秒で制御）:
const data = new Uint8Array(chunk.byteLength);
chunk.copyTo(data);
muxer.addVideoChunkRaw(data, chunk.type, finalTsMs, durationMs, meta);
```

**addVideoChunkRaw()のシグネチャ:**
```typescript
addVideoChunkRaw(
  data: Uint8Array,         // チャンクデータ
  type: 'key' | 'delta',    // フレームタイプ
  timestamp: number,         // タイムスタンプ（ミリ秒）← 完全制御
  duration: number,          // 継続時間（ミリ秒）← 完全制御
  meta?: EncodedVideoChunkMetadata  // decoderConfig等
): void;
```

### 期待される動作
1. VideoEncoderは従来通りマイクロ秒単位で出力（33333μs）
2. `chunk.copyTo(data)`でバイナリデータを取得
3. **timestamp/duration両方を÷1000でミリ秒変換**
4. `addVideoChunkRaw()`で完全制御して渡す:
   - Chunk 1: ts=0ms, dur=33.33ms
   - Chunk 2: ts=33.33ms, dur=33.33ms
   - Chunk 3: ts=66.67ms, dur=33.33ms
5. STTSテーブルが正常構築（1135エントリー、各33.33ms）
6. **VLC正常再生！**

### 次ステップ
1. **Ctrl+Shift+R で完全リロード**
2. エンコード実行
3. **VLCログ確認**:
   ```
   mp4 debug: track[Id 0x1] read 1153 samples length:38s  ← 正常
   mp4 debug: STTS table of 1135 entries  ← 修正されているはず！
   ```
4. **VLC再生**: 正常に映像表示されるか確認

---
2. **テスト実行**して新ログを確認
3. `videoChunkAddedCount` の値を確認：
   - **0**: 全チャンク失敗 → muxer API が根本的に受け付けない
   - **1134**: 全チャンク成功 → 問題は muxer.finalize() または fileStream 側
   - **部分的**: 特定フレームで失敗 → そのフレームの属性（timestamp/duration）に問題
4. エラーメッセージ内容をキャプチャして、mp4-muxer の仕様確認

### 代替案（必要に応じて実装）
- **案A**: chunk を直接 muxer に渡す（metadata オーバーライド無し）
- **案B**: chunk data を抽出して新規 EncodedVideoChunk を生成（timestamp=0）
- **案C**: 別の muxer ライブラリに切り替え（ffmpeg.wasm など）

---

## 2026-01-13（修正実装版）mp4-muxer timestamp 問題の解決

### 根本原因の再分析
ログを詳しく読み込むと、以下の事実が判明：
```
Total video chunks added to muxer: 0  ← すべてのチャンク追加が失敗
✗ Failed to add chunk #1135: normalizedTs: 0, chunk_type: 'delta'
  → normalizedTs は 0 で正規化されているのに、muxer が拒否
  → metadata.timestamp が mp4-muxer に認識されていない可能性
```

**mp4-muxer v3.0.1 の問題：**
- EncodedVideoChunk.timestamp は読み取り専用プロパティ
- metadata で timestamp を上書きしても、ライブラリがオリジナルの chunk.timestamp をチェックしている
- `firstTimestampBehavior` オプションが**バリデーション前に処理されない**

### 実装修正（最終版）
**encoder.js を修正：**

VideoEncoder/AudioEncoder の output callback で、**最初のチャンク時に timestamp を絶対的に 0 にセット：**
```javascript
// 最初のチャンクは timestamp: 0 として絶対値で指定
const finalTs = videoChunkCount === 1 ? 0 : normalizedTs;
const metaAdj = { timestamp: finalTs, duration: chunk.duration };
console.log(`Attempting chunk #${videoChunkCount}: timestamp=${finalTs}, duration=${chunk.duration}, type=${chunk.type}`);
muxer.addVideoChunk(chunk, metaAdj);
```

- **videoChunkCount === 1**: 最初のチャンク（#1）の metadata.timestamp を 0 に絶対指定
- **videoChunkCount > 1**: 2番目以降は normalizedTs（正規化値）を使用
- **flush 時の追加フレーム（#1135以降）**: 同じロジックが適用（videoChunkCount でカウント継続）

AudioEncoder についても同様の修正を適用

### テスト方法
1. ブラウザキャッシュクリア（Ctrl+Shift+R）
2. 同じビデオで再エンコード
3. コンソールで以下を確認：
   - `Attempting chunk #1: timestamp=0, ...` ← 最初のチャンクが timestamp=0
   - `Attempting chunk #2: timestamp=33333, ...` ← 2番目以降は正規化値
   - `✓ Video chunks added: X/1134` ← 成功カウントが増える
   - `✗ Failed to add chunk` メッセージが少ない、または出現しない

4. 出力ファイルサイズを確認：
   - 成功時：数MByte（フレームデータ含む）
   - 失敗時：1021 バイト（ヘッダのみ）

### 予想される改善
- VideoEncoder/AudioEncoder が正常にチャンクを muxer に追加
- muxer.finalize() でビデオデータが正しく書き込まれる
- 出力ファイルが再生可能な MP4 になる

---

## 2026-01-13（最終修正）二重エンコーディング問題の解決

### **真犯人を発見**
ログ順序を詳しく分析：
```
1. First video chunk received, chunk.timestamp: 0      ← encoder.js:36
   → demuxAndDecode() 実行中に最初のフレーム出力
2. Warning: totalVideoDurationUs is 0                 ← encoder.js:83
3. Detected format                                     ← encoder.js:149
4. VideoEncoder reconfigured                          ← encoder.js:179
5. AudioEncoder configured                            ← encoder.js:240
6. Flushing encoders                                  ← encoder.js:243
7. videoBaseTsUs initialized: 37800000                ← encoder.js:42
   ↑ ここで初めて if(muxer) チェック！
```

**根本原因：**
- `demuxAndDecode()` が呼ばれた瞬間、ファイルから decode が開始
- VideoEncoder.output callback が即座に呼ばれる（フレーム出力）
- **しかし muxer はまだ初期化されていない** → `if (muxer)` = false
- 結果：**すべてのフレーム出力時に muxer に追加されない**

### 修正内容（フロー変更）
**従来（失敗版）：**
```
1. VideoEncoder/AudioEncoder 初期化
2. demuxAndDecode() 実行 ← フレーム出力が即座に始まる
3. muxer 初期化 ← 遅すぎる！フレームはすでに出力済み
4. エンコード完了
```

**修正版（成功版）：**
```
1. demuxAndDecode() を1回実行 → format 検出のみ
2. VideoEncoder/AudioEncoder を re-configure
3. **muxer を初期化** ← フレーム出力前！
4. AudioEncoder 初期化
5. demuxAndDecode() を2回実行 → **muxer 準備完了の状態でエンコード**
6. 全フレームが muxer に追加される
7. エンコード完了
```

**encoder.js の変更：**
- `demuxAndDecode()` の呼び出しを2段階に分割
- **Step 1**: format 検出用に1回実行
- **Step 2**: format に基づいて encoder/muxer 初期化
- **Step 3**: muxer 初期化 ← フレーム出力前
- **Step 4**: AudioEncoder 初期化
- **Step 5**: 実際のエンコーディング（muxer 準備完了）で再度実行

### テスト方法
1. ブラウザ完全リロード（Ctrl+Shift+R）
2. 同じビデオで再テスト
3. コンソール確認：
   ```
   STEP 1: Detecting format...
   Detected format: {video: {...}, audio: {...}}
   STEP 3: Initializing Muxer BEFORE encoding starts...
   Muxer initialized, ready for encoding
   STEP 5: Starting actual encoding with muxer initialized...
   Total video chunks added to muxer: 1134  ← 全数追加成功！
   Total audio chunks added to muxer: X
   Encode complete!
   ```
4. 出力ファイルサイズが数 MB 以上であることを確認

### 予想される結果
- ✅ 全フレームが muxer に追加される
- ✅ 出力ファイルが再生可能な MP4 になる
- ✅ mediainfo で FrameCount > 0、Duration > 0 が表示される

---

## 2026-01-20 静的サイト化開始（GitHub Pages 対応）

- Vite 設定を GitHub Pages 用に更新（`base: /2nd_IT-Project_BrowserVideoEncoding/`、出力先 `docs/`）。
- バックエンド API 依存を削除し、プリセットはローカル保存（`localStorage`）＋デフォルトプリセット2種に変更。
- API クライアント `src/lib/api/client.js` を削除、新たに `src/lib/presets.js` を追加。
- バックエンド一式（`video-encoder-app/backend/` と `database.sql`）を削除し、完全静的化。
- エンコード完了メッセージをクライアント内で完結表示するよう変更（送信処理を廃止）。
- GitHub Actions を追加し、`main` への push で frontend をビルドし `docs/` を Pages へデプロイするよう自動化（`.github/workflows/gh-pages.yml`）。

## 2026-01-13 出力ファイルが真っ黒（フレーム表示されない）問題の調査

### 症状
- ファイルサイズ：正常（数 MB）
- 再生時：真っ黒画面（フレームが表示されない）
- mediainfo 結果：未確認

### 原因調査用のログ強化
**encoder.js に詳細なフレーム情報ログを追加：**

1. **最初の decode フレーム情報**：
   ```javascript
   🎥 FIRST DECODED FRAME: {
     format, width, height, displayWidth, displayHeight, timestamp, duration
   }
   ```

2. **最初の encode フレーム情報**：
   ```javascript
   🎬 FIRST VIDEO CHUNK: {
     size, timestamp, duration, type, isKeyFrame
   }
   ```

3. **チャンク追加の詳細ログ**：
   ```javascript
   [CHUNK 1] ts: 0, dur: ..., type: key
   [CHUNK 2] ts: ..., dur: ..., type: delta
   ```

### テスト手順
1. ブラウザキャッシュクリア（Ctrl+Shift+R）
2. 同じビデオで再テスト
3. コンソールで以下を確認：
   ```
   🎥 FIRST DECODED FRAME: { format, width, height, ... }
   🎬 FIRST VIDEO CHUNK: { size, type, isKeyFrame }
   [CHUNK 1] ts: 0, dur: ..., type: key  ← 最初が key frame であることを確認
   [CHUNK 2] ts: ..., dur: ..., type: delta
   [CHUNK 500] ts: ..., dur: ..., type: ?
   ...
   Total video chunks added to muxer: 1134
   ```

### チェックポイント
- ❓ 最初のエンコード出力 `type` が `key` か `delta` か？
- ❓ フレームの width/height と encoder 設定が一致しているか？
- ❓ timestamp が 0 から始まり、連続して増加しているか？
- ❓ duration が一定値か？（例：全フレーム 33333 μs）

---

## 2026-01-13（最終修正）VLC再生失敗問題の根本解決

### VLCデバッグログ分析結果
```
mp4 debug: stss gives 0 --> 0 (sample number)  ← キーフレームテーブル破損
mp4 warning: STTS table of 1 entries  ← タイムスタンプテーブルが1エントリのみ
mp4 warning: no chunk defined  ← オーディオチャンク0個
mp4 warning: cannot select track[Id 0x2]  ← オーディオトラック選択不可
main error: buffer deadlock prevented  ← デコーダーデッドロック
```

### 真犯人特定
コンソールログから：
```
[CHUNK 1500] ts: 0, dur: 33333, type: delta  ← 全チャンクのtimestampが0
[CHUNK 2000] ts: 0, dur: 33333, type: delta  ← 連続したタイムスタンプがない
```

**根本原因：**
- 2回目の `demuxAndDecode()` 実行時に `videoChunkCount` がリセットされていない
- そのため、全チャンクが `videoChunkCount > 1` となり、timestamp正規化ロジックが適用される
- しかし `videoBaseTsUs` も再初期化されないため、全チャンクが timestamp=0 として muxer に追加
- 結果：STTSテーブルが破損、キーフレーム情報が不正、VLCが再生できない

### 修正内容
**encoder.js の STEP 5 前にカウンターリセット追加：**
```javascript
// ⚠️ 重要：2回目のエンコード前にカウンターをリセット
frameCount = 0;
videoChunkCount = 0;
audioChunkCount = 0;
videoChunkAddedCount = 0;
audioChunkAddedCount = 0;
videoBaseTsUs = null;
audioBaseTsUs = null;
console.log('✅ Counters reset for second encoding pass');
```

これにより：
1. 2回目のエンコード時に `videoChunkCount` が1から開始
2. 最初のチャンクが timestamp=0、2番目以降が正規化タイムスタンプとして追加
3. STTS/STSSテーブルが正常に構築される
4. VLCが正常に再生可能

### 期待される結果
- ✅ [CHUNK #1] ts=0 (最初のチャンク)
- ✅ [CHUNK #2] ts=33333 (正しいタイムスタンプ)
- ✅ [CHUNK #3] ts=66667 (連続したタイムスタンプ)
- ✅ VLC再生: 正常に動画とオーディオが再生される
- **案C**: 別の muxer ライブラリに切り替え（ffmpeg.wasm など）

